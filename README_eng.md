# PonD(Proof of network Dispersity) BlockChain Project
(translated by \@nuszjj from [中文版](/README.md))
## Project Introduction
This project is aimed to build a set of blockchains with a new consensus protocol: Proof of network Dispersity, which could solve some common problems of existing POW and POS protocol to make it more environment friendly and fairer. On top of that, a series of blockchains with different tasks and functions will be established, necessary rewards will be distributed to developers within the protocol layer and simplify the business model of side-chain projects, which eventually makes this project as an open scalable system, and provides a safer, fairer and more flexible platform in the blockchain, especially cryptocurrency industry.<br>
## Proof of network Dispersity
*(Patent NO. CN2018102289423)*<br>
### Design Background
My initial design intention is to create an unduplicated proof of capability by making use of the feature of network lantency to realize POW consensus with low energy consumption.<br><br>
The "Proof of work" protocol is being criticized because of the energy consumption. But regardless of the energy problem, POW is still the most essential and effective method of the blockchain system. With the logic of "able people should get more pay", proof-of-work is the first consensus protocol that makes a total decentralized system work. All of the other protocols are following the same logic, like Proof of Activity, Proof of Burn, Proof of Storage, Proof of Elasped Time, and so on. "Proof of stake" is the most popular one of them because it doesn’t need any external resources and consumes low energy by expanding the main logic from "able people should get more pay" to "rich people should get more pay", which makes the mining competition is only among the static inner states and there is no need for power consumption. But "POS" mode has its own flaw such as "nothing at stake" which can casue multiple voting problem, "stake grinding attack" and so on. An inevitable problem of "POS" is caused by the logic: "rich people should get more pay". Whenever the miners spend the same amount of time, the richer ones earn more, so that the rich miners tend to spend more time to work than others. In that case, the rich miners will gradually become richer and richer and this process will be ever-accelerated until there are only some richest users left in the system. By the way, some POS protocols offer "interests" to every stake holders to replace the mining process. It seems that they resolved the problem above but those protocols are vulnerable for lack of incentive to maintain the network.<br><br>
The original intention of this article is to find another low energy consumption "proof of ability" to replace "proof of stake". Considering the following fact: because of the network lantency, you have to use as many distributed nodes as possible in order to pick up distributed information in the network as fast as possible. And this is a kind of "ability" that can't be improved by enhancing the performance of a single machine or using more electric power. But in the process of the designing, I realized that the "stake" property is essential and the best choice is to use both "ability" and "stake" at the same time and users will determine by themselves whether to use "stake" or "ability". Guide the users with appropriate profit distribution and it is possible to ensure the most fairness and safety.<br>

### Benifits
Compared with "POW" and "POS", this model has the following benefits: <br>
* **No hashpower competition and no high-energy-consumption;** [->](#anchor-02)
* **No "nothing at stake" and "stake grinding" attack;**[->](#anchor-03)
* **Optimize wealth distribution logic based on "stake" and replace all the inactive nodes with miners to maintain the network;**[->](#anchor-04)
* **The new way of mining competition helps change the environment of App or website development and improve the user experience.**[->](#anchor-05)<br>

*(note: Because this article is only discussing the situation of fully decentralized systems, protocols like "PBFT", "DPOS", "Ripple" will not be involved.)*<br><br>
### Scenarios and Characters
The whole network can be imagined as kind of scenario that the bee is gathering honey. There are 3 types of characters according to the node's functions.<br>
1.	Flower node<br>
Each node that broadcasts a transaction could be a Flower node which is mainly responsible for answering the request of Workers and voting for the main chain. The stake that a Flower node holds is seen as "Honey" in this scene and the amount of "Honey" will influence miner's competition.<br>

2.	Honeycomb node<br>
Honeycomb nodes are miners who have their own Workers gathering "honey" for them in the network. Honeycomb nodes use the "honey" they gathered to compete for generating blocks. Any user could be a Honeycomb node.<br>

3.	Worker(bee) node<br>
Workers are attached to Honeycombs in order to detect the Flowers nearby and send a "Honey-gather" request as soon as possible. The process that one Flower node answers the request from one Worker is seen as "Honey gathering".<br><br>

The network scheme is shown as below:<br>
![Alt text](/res/charactors.jpg)<br>
Figure 1: nodes & network scheme illustration<br>

### Consensus Process
>1.	**Before publishing a transaction, a Flower node will broadcast a signal to preannounce it. The Workers nearby send "Honey gather" requests back when they detect the signal.**
>2.	**After receiving the first request from a Worker, the Flower packs the main chain’s (about selecting the main chain, refer to the GHOST protocol) tail-block "b" and the address "m" of the Honeycomb who owns the Worker into the transaction structure , and then broadcasts the transaction. A successful "Honey gathering" is completed.**<br>
*(note：We need to add those two 32-byte fields "b" and "m" to the transaction field. And a "balance" field is needed too if other place does not store stakes of the account.)*
>3.	**This transaction is validated and packed into a new block by another miner, and then broadcasted in the network.**
>4.	**When a Honeycomb receives a new block, he begins to validate it. At the same time, the Honeycomb checks the field "b"f and "m" of each transaction. Mark the transactions with "x" when their "m" fields point at the Honeycomb himself and mark them with "y" when   their "b" fields match the current chain’s tail-block.**
>5.	**Equally divide the balance of each Flower between all of its transactions in that block.**
>6.	**Add up the balances divided at the previous step of all the transactions marked with both "x" and "y" until the Honeycomb meets the target of generating a block. The result is denoted by "X" and the max number of statisticed blocks is 100.**<br>
*(note: The "x" mark means the vote of generating blocks, but why we also need to check the "y" mark, refer to Chapter "[Frauds and attacks](#frauds-and-attacks)" Article 1.)*
>7.	**Add up the divided balances of the transactions marked with "y" only in the current block and denote the result by "Y".**<br>
*(note: The "y" mark means the vote of the main chain and there will be some adjustment about "Y", refer to Chapter "[Frauds and attacks](#frauds-and-attacks)" Article 2.)*
>8.	**The Honeycomb is trying periodically to meet the target of generating a block with a mathematical operation based on constants such as timestamps and private signatures. That is denoted by: proofFunction() < target\*d\*X\*Y, "d" means the difficulty adjustment parameter. Other blocks received during that process, competing for the main chain, should be parallel processed. In order not to weaken the main chain, dthere is no need to stop competing for the current chain if the weight of main chain is less than the existing chain plus eight, and it actually follows its own benefits (possible to main chain).**<br>
*(note: The trying frequency should be floating, refer to Chapter "[Frauds and attacks](#frauds-and-attacks)" Article 1.)*
>9.	**After meeting the target of generating a block, the Honeycomb packs all of the transactions received during this period into a new block and broadcasts it. All of the "xy" marked transactions (coded within 100 blocks in order to save some space), profits of all nodes and other parameters should also be packed for verification. Mining rewards will be distributed proportionally between miners and all the flower nodes marked with xy.**<br>
*(note: Profits distribution strategy is discripted in Chapter "[Reward distribution](#reward-distribution)")*<br>
*(note2: in terms of the extra storage space for validation parameters and reward distribution, it could be 2 more bites in the ID of each transaction and 4 more bites in the profit at maximum, which is fully acceptable; additional work of block validation is only going through the last 100 blocks, and it will not cause too much computation with proper algorithm.)*<br>

<br>

* For better understanding, the steps can be briefed as:<br>
   **"The Honeycombs are constantly gathering honey all over the network and the result of the gathering is saved in the blocks. The probability of a Honeycomb wins the competition of generating a block is in proportion to the honey he gathered. The Flowers vote on the main chain with their stake every time they publish a transaction and the result is saved in blocks. The probability of a block to be accepted is in proportion to the stake voted for it."**<br>

* Shorter description:<br>
   **"Every time they publish a transaction, the stakeholders vote with their stake on the miners to generate a block and on the branches to be accepted as part of the main chain. The more stake a block or a miner get, the higher chance they win the competition."**<br>
*(note1: to control the voting frequency, it is necessary to count the block gap when the last transaction arrives at current block in each account, and take a certain granularity, such as 10 blocks, as the adjustment coefficient. From zero, every unit time, the coefficient increases proportionally, and only after a long interval, like 6000 blocks, around 100 hours, coefficient can be restored to the maximum; also, the same adjustment coefficient will be added to each UTXO, and transaction frequency can adjust the number of stakes with the same approach and parameters as the former.)*<br>
*(note2: the introduction of voting time granularity is to restrict the voting frequency, reduce relevant transactions when generating blocks, and increase validation rate of blocks and transactions.)*<br>
*(note 3: to improve efficiency, we can add more transactions with pure voting, and users are able to decide whether they want to participate in the voting for the current transaction within the range of voting frequency.)*<br>

<br>
The following diagrams show the principle about voting for block generation (x vote) and main chain (y vote) respectively:<br>

![Alt text](/res/vote_on_x.jpg)<br>
Figure 2: Process of block generation vote and validation<br>
As shown in the scheme above, the system will count votes in certain existing blocks and the honeycomb with maximum votes can have the highest chance to win the competition.<br><br>

![Alt text](/res/vote_on_y.jpg)<br>
Figure 3: Process of main chain vote and validation<br>
As shown in the scheme above, whenever there is any fork, the transactions will also vote for the branch, which determines the number of votes (stakes) for different branches in the next voting, i.e. the amount of block generation difficulty parameter Y is determined. Thus, the more votes one branch can get, the faster it will be to generate the next block, and the faster broadcast is helpful to gain more votes in the next round. This process will increase the gap between these two branches and determine the main chain in short time.<br>

<a id="anchor-01">The reason why separating the voting for mainchain and transaction record is because it could make stakes decide the branch individually. Because miners will only compete for votes of generating blocks, but votes for mainchain has none business with their income, which makes it not necessary to influence objective of the voting. In addition, it is difficult to control the users because they only need to vote their desired mainchain according to the blockchain data. So even if the users are quite centralized, it also can protect attack to branches effectively. The consensus protocol includes kind of incentive mechanism to the wallet program (refer to “[Wallet application](#wallet-application)” section for more details), which encourages users to select free competition and further ensure the stability of the mainchain.</a><br>

<a id="anchor-02">According to the consensus process above, if the miners would like to get more advantages in the competition, they have to earn more distributed workers to react to random signals from the flower nodes in the network. Thus, the competition mechanism is impossible to be simulated in single computer, which avoids the competition by only infinitely increasing the performance of mining machines and ensure the mining fairness. [benifits<-](#benifits)</a><br>

<a id="anchor-03">Like PoS protocol, we don’t need any external resources. The difference is that when we count the votes, they are already sealed in the past blocks. That makes the “nothing at stake” and “stake grinding” problem resolved. [benifits<-](#benifits)</a><br>

<a id="anchor-04">Another difference from PoS is: Because of the existence of the miners, stakeholders could hand over their job to them by the voting process. Miners can help to complete the competition even though the users with low stake are not so positive. Users only need to vote once within a voting cycle to make sure that the holding stakes would not miss the voting activities, which can basically avoid the unequal wealth distribution issue as discussed earlier. [benifits<-](#benifits)</a><br>

<a id="anchor-05">Meanwhile, the structure of honeycomb and worker bee can be embedded in App and website development, and I hope it could help some developers to get out of the dilemma in which they only can get revenue with advertisement, or make some contribution to generate better users experience while using the App or website. [benifits<-](#benifits)</a><br>

### Compete for the flower nodes
To achieve the ability with faster block generation, the honeycomb will try the best to compete for as many as possible flower nodes. My initial design idea is that everybody can use more workers to get honey, like embedding worker bee program to the app, if the developers would like to gain more workers, they have to upgrade the apps for better user experience progressively. But it is inevitable that some users may reach agreements with each other to cooperate mining as team (e.g. wallet or mining pool). In this case, we would like to provide some alternatives in the transaction structure, which means you can either choose type A – accept honey gathering from worker bees with the form of broadcast; or type B- designate one miner and make him win the voting; or even type C – designate yourself and work on mining individually. It looks like that there is some influence on the fairness, but in fact, if we consider from the point of miners, it is beneficial for the healthy development of the network if they can compete with each other to attract users via adjusting the distribution plan, because eventually there will be diversified unions with different sizes, which compete with worker bees for the rights to generate blocks. All these unions or individuals participate in the competition with the mode similar to POS, which could effectively reduce the risk that honeycomb with tremendous workers would control the voting process.<br><br>
#### Wallet application
Here, we would like to discuss sort of special app – wallet application because it even can guide users to decide the transaction type and voting targets. However, considering their own benefits, majority of wallet applications will choose type B to mine for themselves, or give higher priority to their own honeycombs, which voids the chances for other ordinary honeycombs to participate in the competition. Therefore, there needs a mechanism to encourage wallet applications to select as many type A as possible and it provides wallet applications with legitimate way to earn income. E.g.: increase the field of wallet income in type A transactions, and distribute some of the revenues to the operators of wallet applications, but type B and C don’t have this kind of rewards. One extra benefit if we do like this, it can encourage to develop better wallet apps and sidechains to provide incentives for open platform. (refer to "[Multi chain](#multi-chain)" section)<br><br>
#### PoS variant
We can also derivate a variant for this consensus, i.e. there is only type C. In this case, everybody can mine with their own stakes and it becomes pure PoS consensus. This variant system also can ensure the fairness and solves several issues under traditional PoS mode (refer to the section of “design intention”). Nevertheless, due to the wealth distribution issue which PoS mode can never escape, I personally prefer the original mode to construct the blockchain, because in term of the stake distribution, miners in type A and B also play important roles (refer to [->](#anchor-04)).<br><br>

### Reward distribution
If the distribution strategy of mining rewards is different, users may make some changes to the network structure and individual behaviors. The distribution we are talking about is only for A type mining, because mining rewards distribution for type B is completed by miners, and there is no distribution requirement for type C mining. And we need to consider some questions as following:
1.	To avoid that the honeycomb will divide itself to get more benefits, honeycomb should achieve rewards according to the fixed proportion of total amount.
2.	The stake distribution weight will influence user's choice, and absolute fair distribution mechanism may not be enough to attract more ordinary users if we follow exactly the stake distribution. But if the stake weight is too low, we would lose too many high-stake users.
3.	After decreasing the stake weight, it is necessary to make transaction fee as reference to avoid that users will divide their account infinitely to get more revenues, and it also can provide customers who have different requirements with more alternatives to play a role in regulation.

Therefore, the best solution for distribution plan of type A mining is to be affected by both parameters of stake and transaction fee, e.g. miners share 20% of total rewards, and the rest will be divided into two parts, 1/3 of which is distributed according to transaction fee, and the other 2/3 is based on stakes. (“Stake” means accumulated stakes of X parameter, and each flower node could be duplicated). 25% of rewards from flower nodes (i.e. 20% of total amount) will be distributed to wallet account.

However, as for distribution plan of type B mining, it is determined by miners according to the agreed mining program between miner and user. It is relatively more free, but there are also some restrictions: to ensure the benefit of wallet applications ( refer to section of “[Wallet application](#wallet-application)”) is always higher than that from wallet mining, B type miner rewards percentage must be restricted under wallet rewards out of type A mining, i.e. under 20%.

The default transaction fee of different voting plans could be adjusted according to the average number of people who participated in type A and B block mining every time. If this number N is lower, it means there are more miners joined, so we can reduce transaction fee to attract more users and match the number of miners. Actually, even if there is no adjustment above, the economic principle would also help people to make such balance, just a little slower. In addition, it is also possible to regulate the distribution ration of the honeycombs according to the number N: decrease distribution ration if there is less people, and attract more users to select type A mining. Meanwhile, it also can help to reduce the number of honeycomb nodes and accelerate the network architecture adjustment.

### Frauds and attacks
1.	Filtered transaction, miners only pack the transactions which are beneficial to them.
Because the transactions included in each block could influence the competition environment, miners may want to gain more advantages through choosing some of the transactions.
First of all, transactions in each block only take up small percentage of total amount, so there is little influence on the statistic results if some changes are made in one block. To solve this kind of problem better, we need to count the sum of stakes of all the flower nodes in this transaction, which will be used for next block generation interval. The higher stake it has, the shorter calculation period it will have, otherwise it is longer. E.g. if we make the calculation period between 0.9-1.1 secs, it would directly affect next block generation. In this case, it would be better choice for packing as many transactions as possible, which could disincentive the miner frauds. This parameter should be adjusted per the average value every once in a while.
Maybe you have one doubt: why we need also refer to y when accumulating the stakes, not directly take x as reference? Of course, if we don’t take y, there would be no question, but it is hard to understand: it is meaningless by logic if we take account into the results of branches when counting the votes. However, there is one unique advantage to do like this. Nobody will get any revenue if they select wrong branch, which facilitate users to be more careful in the branch selection, not just make a choice anyway, or even give up. Although there may have some inaccurate statistics in this case, it could be neglected if compared with the benefits we discussed and there is also very low chance to get orphan block in practice.

2.	It’s also filtered transaction, but the purpose is to influence the branch development speed
Because the transactions included in each block will also decide the speed of next block generation in the same chain ( influence parameter Y), and attackers could decrease the transactions deliberately in certain branch to affect determination of the mainchain.
Solution: In step 4 of the consensus process, when checking the transaction address b, other than marking the transaction at end of the current chain as y, we also need to mark the transaction that points to the current chain's countdown second, third (quantity adjustable) block, which is y1. Both y and y1 shall be counted when calculating the value of y. In this case, even though the attacker reduces the speed of certain block generation, it will compensate the deliberate missing block if only the latter miners are honest. All the transactions will point to the countdown second block and backwards.
Another doubt may come out: is it possible to count transactions marked with xy1 when calculating X parameter? In this case, even though somebody makes fault during packing the transactions, there will be no effect on the results because the latter miners can make compensation for that. The answer is no because if we do like this, the nodes will evade the crucial point when there are branches and vote for the blocks before that to make sure they are critical. This can interfere the competition between branches, which makes it hard to determine the main chain promptly.

3.	51% attack
If any user gains over 50% resources, they system will be totally under his control, which is the same with other algorithm. Here we would like to analyze which level of attack users can launch if under 45% resources.
Let’s remain the same settings as before, the block generation period is 60s, stake recovery period is 6000 blocks interval, and averagely each block has 1/6000 stake of total blocks. In this case, we choose 100 blocks as statistic interval, so averagely in each block generation, there will be (1/6000)*100=1/60 stake involved in the competition. Therefore, if you want to control the block generation, it only requires to put 1/120 stake in each block. For example, suppose one user has 50% stake and hold all of them longer than 100 hours, then he can make sure “double spend” attack within (50%)/(1/120)=6 blocks. In conclusion, if we have a significantly important transaction, wait one hour before we make the decision to ensure absolute safety.
The statistic interval of 100 blocks is a very conservative design because we haven’t started deep research and experiments on data search algorithm. To prevent bottlenecks in verifying blocks and transactions, it is temporarily set as 100 blocks. In fact, according to existing database’s search rate, we estimate there is a lot of room for improvement with appropriate design. Suppose the statistic interval could be raised to 1000 blocks, the security of the system will increase by 10 times, and so on.

4.	Simulate worker bee, i.e. try to create large number of worker bee nodes by simulation and add those virtual nodes to the p2p network to increase the probability of successful nectar extraction.
To deal with this situation, we can make some control when creating the p2p network, e.g. every client only needs to build connection with the first M nodes which has the fastest response speed.

### Speed of block generation
The same as Bitcoin, we are fully decentralized system, so there will be some restrictions on the block generation speed. However, under this consensus mode, the capability of block generation is actually closely related with network respond time. The honeycombs with higher chance to generate blocks will have shorter time to receive broadcast of new blocks, while it doesn’t matter much if the honeycombs which have lower ability of block generation receive the broadcast with some delay. In addition, I switch the main chain selection protocol from POW to GHOST, which can be more effective against attack after producing orphan blocks. Thus, the consensus period in our system may be a little longer than Bitcoin. (we still lack experimental data for how many blocks will be generated in one minute)

If we want to achieve kind of blockchain with high circulation rate in which the blocks are generated in turns among a few nodes, like DPOS, it only needs some modifications in another variant of this consensus. When there are only type B miners in the system, our consensus itself is one kind of voting mechanism and we can modify based on that, e.g. simplify validation process, cancel competition mechanism and reward distribution, cancel the voting of main chain and so on.

## General plan of the project
### Multi chain
Because of very low cost for merged mining with this consensus protocol, it only needs one more thread to verify one more chain. Also, the computing power attack will not occur since there is no parasitism. Thus, we have more advantages over POW to run side chains.

The degree of decentralization in blockchain determines how robust it is, but it also restricts the speed of network synchronization, which limits the block generation speed as well. Robust and transaction volume become two contradictory features in the blockchain development. On the other hand, the more complex design blockchain has, the more function it can implement, but at the same time, it will bring more insecurity factors due to complicated codes. It is quite difficult to build a perfect blockchain, so it could be a good idea to process data with different requirements by putting them into different chains. Users could store most of their funds in the main chain with full decentralization, more security but lower speed. Then part of their fund will be transferred to certain side chain for micro transactions or other business. Side chain could be designed as high-speed chain which scarifies some security but improves the performance (refer to section of “[Speed of block generation](#speed-of-block-generation)”), or more complicated business chain with smart contract function, and son on. It could also be good choice if embedded in other blockchains.

Meanwhile, because it distributes some rewards to developers as incentive ( refer to section of “[Wallet application](#wallet-application)”) on the protocol level and hopes this could encourage more developer teams join the development of side chain to bring fresh blood to the healthy growth of the whole system.

### Upfront plan
So far, our plan is to get two chains, one of them is used to provide the most secured cryptocurrency protection and trading function, and the other business chain can realize exchange transactions of third party arbitration (refer to “Decentralized Exchange” for more details). We may give priority to the development of high-throughput micro transaction chain and the business chain that can run smart contracts depending on the team situation and technical details. And optimize the interface standard to make it more convenient to interact with other projects, as mentioned earlier, the target of this project is to construct a scalable multi-functional blockchain and it is certainly essential to realize value transfer between different developers and projects.
